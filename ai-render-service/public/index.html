<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AI Render Service - Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      padding: 30px;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    h1 {
      color: #333;
      margin-bottom: 10px;
    }

    .subtitle {
      color: #666;
      margin-bottom: 30px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }

    input[type="text"],
    select {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    input[type="file"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
      background: white;
    }

    button {
      background: #007acc;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 4px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      width: 100%;
      margin-top: 10px;
    }

    button:hover {
      background: #005a9e;
    }

    button:disabled {
      background: #ccc;
      cursor: not-allowed;
    }

    .status {
      margin-top: 20px;
      padding: 12px;
      border-radius: 4px;
      display: none;
    }

    .status.success {
      background: #e8f5e9;
      border-left: 4px solid #4caf50;
      color: #2e7d32;
      display: block;
    }

    .status.error {
      background: #ffebee;
      border-left: 4px solid #f44336;
      color: #c62828;
      display: block;
    }

    .status.info {
      background: #e3f2fd;
      border-left: 4px solid #2196f3;
      color: #1565c0;
      display: block;
    }

    .footprint-confidence-badge.high { background: #e8f5e9; color: #2e7d32; }
    .footprint-confidence-badge.medium { background: #fff8e1; color: #f57f17; }
    .footprint-confidence-badge.low { background: #ffebee; color: #c62828; }

    /* ConstructaOS branded loading state */
    .constructaos-loading {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 24px 20px;
      background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
      border: 1px solid #dee2e6;
      border-radius: 8px;
      min-height: 120px;
    }
    .constructaos-loading-line {
      width: 120px;
      height: 3px;
      background: linear-gradient(90deg, transparent, #212529, transparent);
      background-size: 200% 100%;
      animation: constructaos-shimmer 1.4s ease-in-out infinite;
      border-radius: 2px;
      margin-bottom: 16px;
    }
    .constructaos-loading-line::before {
      content: '';
      display: block;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent 0%, rgba(33,37,41,0.15) 50%, transparent 100%);
      animation: constructaos-shimmer 1.4s ease-in-out infinite 0.2s;
      border-radius: 2px;
    }
    @keyframes constructaos-shimmer {
      0% { background-position: 200% 0; }
      100% { background-position: -200% 0; }
    }
    .constructaos-loading-brand {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.12em;
      color: #495057;
      margin-bottom: 10px;
      text-transform: uppercase;
    }
    .constructaos-loading-message {
      font-size: 14px;
      color: #495057;
      text-align: center;
      max-width: 280px;
    }

    #result-container {
      margin-top: 30px;
      display: none;
    }

    #result-container.show {
      display: block;
    }

    #result-image {
      max-width: 100%;
      height: auto;
      border: 1px solid #ddd;
      border-radius: 4px;
      margin-top: 15px;
    }

    .result-info {
      margin-top: 15px;
      padding: 12px;
      background: #f5f5f5;
      border-radius: 4px;
      font-size: 14px;
      color: #666;
    }

    .result-info strong {
      color: #333;
    }

    .prompt-section {
      margin-top: 20px;
      margin-bottom: 20px;
    }

    .prompt-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      background: #f0f0f0;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }

    .prompt-header:hover {
      background: #e0e0e0;
    }

    .prompt-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      color: #333;
    }

    .prompt-toggle {
      font-size: 20px;
      color: #666;
      transition: transform 0.2s;
    }

    .prompt-toggle.expanded {
      transform: rotate(180deg);
    }

    .prompt-content {
      display: none;
      margin-top: 10px;
      padding: 15px;
      background: #f9f9f9;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      max-height: 500px;
      overflow-y: auto;
    }

    .prompt-content.show {
      display: block;
    }

    .prompt-text {
      font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
      font-size: 12px;
      line-height: 1.6;
      white-space: pre-wrap;
      word-wrap: break-word;
      color: #333;
      margin: 0;
    }

    .radio-group {
      display: flex;
      gap: 20px;
      margin-top: 8px;
    }

    .radio-option {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .radio-option input[type="radio"] {
      width: auto;
      margin: 0;
    }

    .radio-option label {
      margin: 0;
      font-weight: normal;
      cursor: pointer;
    }

    .hidden {
      display: none !important;
    }

    .disabled-section {
      opacity: 0.5;
      pointer-events: none;
    }

    .section-divider {
      margin: 30px 0;
      border-top: 1px solid #ddd;
    }

    .section-title {
      font-size: 18px;
      font-weight: 600;
      color: #333;
      margin-bottom: 20px;
    }

    .form-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
    }

    @media (max-width: 768px) {
      .form-row {
        grid-template-columns: 1fr;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>AI Render Service</h1>
    <p class="subtitle">Generate architectural concept renderings from your design brief</p>

    <!-- Vercel Free Tier Warning -->
    <div style="margin: 20px 0; padding: 15px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
      <strong style="color: #856404;">⚠️ Deployment Notice</strong>
      <p style="margin: 8px 0 0 0; font-size: 14px; color: #856404; line-height: 1.5;">
        This service requires <strong>Vercel Pro</strong> for reliable operation. The free tier has a 10-second timeout, but AI rendering takes 20-60 seconds.
        <br><strong>Free tier will result in 504 errors.</strong> For production use, upgrade to Pro or run locally.
      </p>
    </div>

    <div class="section-divider"></div>
    <h2 class="section-title">Generate Concept Renders</h2>
    <p style="color: #666; margin-bottom: 20px;">Create architectural concept views with consistent design across axonometric, isometric plan, and section views.</p>

    <div class="form-group" style="margin-bottom: 20px; padding: 15px; background: #f0f0f0; border-radius: 4px;">
      <label for="preset-select" style="font-weight: 600;">Quick Presets (for rapid iteration)</label>
      <select id="preset-select" style="margin-top: 8px;">
        <option value="">Select a preset...</option>
        <optgroup label="General Presets">
          <option value="suburban-extension">Suburban rear extension, 2-storey, pitched roof</option>
          <option value="urban-infill">Urban infill new build, 3+ storey, flat roof</option>
          <option value="rural-conversion">Rural renovation, 2-storey, mixed roof</option>
          <option value="suburban-renovation">Suburban renovation</option>
          <option value="urban-terrace-refresh">Urban terrace refresh</option>
        </optgroup>
        <optgroup label="Concept Range Comparison (Urban New Build)">
          <option value="compare-grounded">Compare: Grounded - constraint-led</option>
          <option value="compare-exploratory">Compare: Exploratory - testing alternatives</option>
          <option value="compare-speculative">Compare: Speculative - bold &amp; conceptual</option>
        </optgroup>
      </select>
    </div>

    <form id="render-form">
      <div class="form-group">
        <label for="projectId">Project ID *</label>
        <input type="text" id="projectId" name="projectId" required placeholder="Enter project ID" value="test-project-123">
      </div>

      <div class="form-group" style="padding: 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px;">
        <label for="layout-reference-file" style="font-weight: 600;">Layout reference <span style="font-size: 11px; font-weight: 500; color: #6c757d;">(optional, beta)</span></label>
        <p style="margin: 4px 0 8px 0; font-size: 12px; color: #666;">Soft influence only; not a literal drawing. Informs general layout and proportions — the design brief is the primary source. The system works fully without it.</p>
        <input type="file" id="layout-reference-file" name="layoutReference" accept="image/*,.pdf" style="max-width: 100%;">
      </div>

      <div class="section-divider" id="existing-building-section"></div>
      <div id="existing-building-content">
        <h2 class="section-title">Existing building (if applicable)</h2>
        <p style="color: #666; margin-bottom: 20px; font-size: 14px;">Fill in these fields only if you're working with an existing building (extension or renovation).</p>

      <div class="form-row">
        <div class="form-group">
          <label for="existingOrientation">Existing Orientation</label>
          <select id="existingOrientation" name="existingOrientation">
            <option value="">Select existing orientation...</option>
            <option value="north_facing_rear">North-facing rear</option>
            <option value="south_facing_rear">South-facing rear</option>
            <option value="east">East</option>
            <option value="west">West</option>
          </select>
          <span class="estimated-label" id="existingOrientation-estimated" style="display: none; font-size: 12px; color: #666; font-style: italic; margin-top: 4px;">Estimated from map data</span>
        </div>
      </div>

      <div class="form-group">
        <label for="existingDensity">Existing Site Density</label>
        <select id="existingDensity" name="existingDensity">
          <option value="">Select existing density...</option>
          <option value="suburban">Suburban</option>
          <option value="urban">Urban</option>
          <option value="rural">Rural</option>
        </select>
        <span class="estimated-label" id="existingDensity-estimated" style="display: none; font-size: 12px; color: #666; font-style: italic; margin-top: 4px;">Estimated from map data</span>
      </div>
      </div>

      <div class="section-divider"></div>
      <h2 class="section-title">Site Location</h2>

      <div class="form-group">
        <label for="address">Address / Postcode</label>
        <div style="display: flex; gap: 10px;">
          <input type="text" id="address" name="address" placeholder="Enter address or postcode" style="flex: 1;">
          <button type="button" id="lookup-btn" style="width: auto; margin: 0; white-space: nowrap;">Lookup</button>
        </div>
      </div>

      <div class="form-group" id="location-display" style="display: none;">
        <div style="padding: 12px; background: #e3f2fd; border-left: 4px solid #2196f3; border-radius: 4px; color: #1565c0;">
          <strong>Location:</strong> <span id="location-name"></span>
        </div>
      </div>

      <!-- Footprint confirmation (after site lookup, before baseline summary) -->
      <div class="form-group" id="footprint-confirmation" style="display: none;">
        <div class="footprint-confirmation-card" style="padding: 20px; background: #fff; border: 1px solid #e0e0e0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.08);">
          <p id="footprint-confirmation-message" class="footprint-confirmation-message" style="margin: 0 0 16px 0; font-size: 15px; color: #333;">We've identified this building — please confirm it's correct.</p>
          <div id="footprint-map-container" style="width: 100%; height: 280px; background: #f5f5f5; border-radius: 6px; overflow: hidden; margin-bottom: 16px;"></div>
          <div style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; gap: 12px; margin-bottom: 16px;">
            <div style="display: flex; align-items: center; gap: 8px;">
              <span style="font-size: 13px; color: #666;">Confidence:</span>
              <span id="footprint-confidence-badge" class="footprint-confidence-badge" style="display: inline-block; padding: 4px 10px; border-radius: 12px; font-size: 13px; font-weight: 500;"></span>
            </div>
            <button type="button" id="confirm-footprint-btn" class="btn btn-primary" style="min-width: 140px;">Confirm footprint</button>
          </div>
        </div>
      </div>

      <!-- Baseline Summary (from site lookup) -->
      <div class="form-group" id="baseline-summary" style="display: none;">
        <div style="padding: 15px; background: #f5f5f5; border-left: 4px solid #4caf50; border-radius: 4px;">
          <h4 style="margin: 0 0 10px 0; font-size: 16px; color: #333;">Existing Building Baseline (from map footprint)</h4>
          <div id="baseline-details" style="font-size: 14px; color: #666; line-height: 1.6; margin-bottom: 10px;"></div>
          <div id="baseline-selected-footprint" style="display: none; margin-top: 6px; font-size: 13px; color: #1565c0;"></div>
          <div id="baseline-disclaimer" style="font-size: 12px; color: #856404; font-style: italic; padding-top: 8px; border-top: 1px solid #ddd;"></div>
        </div>
      </div>

      <!-- Candidate Selector -->
      <div class="form-group" id="candidate-selector" style="display: none;">
        <label>Not your building? Choose another nearby footprint</label>
        <div id="candidate-buttons" style="display: flex; flex-direction: column; gap: 8px; margin-top: 8px;"></div>
      </div>

      <!-- Manual Overrides -->
      <div class="form-group" id="baseline-overrides" style="display: none;">
        <h4 style="margin: 0 0 10px 0; font-size: 16px; color: #333;">Manual Overrides (optional)</h4>
        <p style="margin: 0 0 15px 0; font-size: 13px; color: #666;">Override inferred values if they're incorrect</p>
        <div class="form-row">
          <div class="form-group">
            <label for="overrideBuildingForm">Building Form Override</label>
            <select id="overrideBuildingForm" name="overrideBuildingForm">
              <option value="">Use inferred value</option>
              <option value="Detached">Detached</option>
              <option value="Semi-detached">Semi-detached</option>
              <option value="Terraced">Terraced</option>
              <option value="Infill">Infill</option>
            </select>
          </div>
          <div class="form-group">
            <label for="overrideStoreys">Storeys Override</label>
            <select id="overrideStoreys" name="overrideStoreys">
              <option value="">Use inferred value</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3+">3+</option>
            </select>
          </div>
          <div class="form-group">
            <label for="overrideRoofAssumption">Roof Type Override</label>
            <select id="overrideRoofAssumption" name="overrideRoofAssumption">
              <option value="">Use inferred value</option>
              <option value="Pitched">Pitched</option>
              <option value="Flat">Flat</option>
              <option value="Mixed">Mixed</option>
            </select>
          </div>
        </div>
      </div>

      <!-- Advanced options (footprint scale override: only when confidence Low or expanded) -->
      <div class="form-group" id="advanced-options-wrap" style="display: none;">
        <button type="button" id="advanced-options-toggle" class="advanced-options-toggle" style="display: flex; align-items: center; gap: 8px; width: 100%; padding: 10px 12px; background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; cursor: pointer; font-size: 14px; color: #495057; text-align: left;">
          <span id="advanced-options-toggle-icon" style="transition: transform 0.2s;">▼</span>
          <span>Advanced options</span>
        </button>
        <div id="advanced-options-content" style="display: none; padding: 16px 0 0 0; border-top: none;">
          <div class="form-group">
            <label for="footprintScaleOverride">Footprint scale override</label>
            <p style="margin: 0 0 8px 0; font-size: 12px; color: #666;">Adjust base massing proportion hint; does not change footprint geometry.</p>
            <select id="footprintScaleOverride" name="footprintScaleOverride">
              <option value="">Use inferred scale</option>
              <option value="compact">Small</option>
              <option value="medium">Medium</option>
              <option value="wide">Large</option>
            </select>
          </div>
        </div>
      </div>

      <div class="section-divider"></div>
      <h2 class="section-title">What you want to design</h2>

      <div class="form-group">
        <label for="projectType">Project Type *</label>
        <select id="projectType" name="projectType" required>
          <option value="">Select project type...</option>
          <option value="extension">Extension</option>
          <option value="renovation">Renovation</option>
          <option value="new_build">New Build</option>
        </select>
      </div>

      <div class="form-row" id="storeys-group" style="display: none;">
        <div class="form-group">
          <label for="storeys">Number of Storeys *</label>
          <select id="storeys" name="storeys">
            <option value="">Select storeys...</option>
            <option value="one">1</option>
            <option value="two">2</option>
            <option value="three_plus">3+</option>
          </select>
        </div>
      </div>

      <div class="form-row" id="numberOfPlots-group" style="display: none;">
        <div class="form-group">
          <label for="numberOfPlots">Number of Plots *</label>
          <select id="numberOfPlots" name="numberOfPlots" required>
            <option value="">Select number of plots...</option>
            <option value="one">1</option>
            <option value="two">2</option>
            <option value="three_to_five">3-5</option>
            <option value="five_to_ten">5-10</option>
          </select>
        </div>
      </div>

      <div class="form-row">
        <div class="form-group" id="floorAreaRange-group">
          <label for="floorAreaRange">Floor Area Range (m²) *</label>
          <select id="floorAreaRange" name="floorAreaRange">
            <option value="">Select floor area range...</option>
            <option value="0_25">0–25</option>
            <option value="25_50">25–50</option>
            <option value="50_75">50–75</option>
            <option value="75_100">75–100</option>
            <option value="100_150">100–150</option>
            <option value="150_200">150–200</option>
            <option value="200_plus">200+</option>
          </select>
        </div>

        <div class="form-group" id="totalFloorAreaRange-group" style="display: none;">
          <label for="totalFloorAreaRange">Total Floor Area Range (m²) *</label>
          <select id="totalFloorAreaRange" name="totalFloorAreaRange">
            <option value="">Select total floor area range...</option>
            <option value="0_25">0–25</option>
            <option value="25_50">25–50</option>
            <option value="50_75">50–75</option>
            <option value="75_100">75–100</option>
            <option value="100_150">100–150</option>
            <option value="150_200">150–200</option>
            <option value="200_plus">200+</option>
          </select>
        </div>

        <div class="form-group" id="additionalFloorAreaRange-group" style="display: none;">
          <label for="additionalFloorAreaRange">Additional Floor Area Range (m²) *</label>
          <select id="additionalFloorAreaRange" name="additionalFloorAreaRange">
            <option value="">Select additional floor area range...</option>
            <option value="0_25">0–25</option>
            <option value="25_50">25–50</option>
            <option value="50_75">50–75</option>
            <option value="75_100">75–100</option>
            <option value="100_150">100–150</option>
            <option value="150_200">150–200</option>
            <option value="200_plus">200+</option>
          </select>
        </div>
      </div>

      <div class="form-group" id="renovationScope-group" style="display: none;">
        <label for="renovationScope">Renovation Scope *</label>
        <select id="renovationScope" name="renovationScope">
          <option value="">Select renovation scope...</option>
          <option value="Light refresh">Light refresh</option>
          <option value="Reconfigure layout">Reconfigure layout</option>
          <option value="Deep retrofit">Deep retrofit</option>
          <option value="Modernise (no extension)">Modernise (no extension)</option>
        </select>
      </div>

      <div class="form-group" id="extensionType-group" style="display: none;">
        <label for="extensionType">Extension Type *</label>
        <select id="extensionType" name="extensionType">
          <option value="">Select extension type...</option>
          <option value="rear">Rear</option>
          <option value="side">Side</option>
          <option value="side_and_rear">Side and Rear</option>
          <option value="wrap_around">Wrap Around</option>
          <option value="two_storey">Two Storey</option>
          <option value="single_storey">Single Storey</option>
        </select>
      </div>

      <div class="form-group">
        <label for="footprintScale">Footprint Scale</label>
        <select id="footprintScale" name="footprintScale">
          <option value="">Select footprint scale...</option>
          <option value="compact">Compact</option>
          <option value="medium">Medium</option>
          <option value="wide">Wide</option>
        </select>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label for="bedrooms">Bedrooms *</label>
          <select id="bedrooms" name="bedrooms" required>
            <option value="">Select bedrooms...</option>
            <option value="zero">0 / None</option>
            <option value="one">1</option>
            <option value="two">2</option>
            <option value="three">3</option>
            <option value="four_plus">4+</option>
          </select>
        </div>

        <div class="form-group">
          <label for="bathrooms">Bathrooms *</label>
          <select id="bathrooms" name="bathrooms" required>
            <option value="">Select bathrooms...</option>
            <option value="zero">0 / None</option>
            <option value="one">1</option>
            <option value="two">2</option>
            <option value="three_plus">3+</option>
          </select>
        </div>
      </div>

      <div class="form-group">
        <label for="kitchenType">Kitchen Arrangement *</label>
        <select id="kitchenType" name="kitchenType" required>
          <option value="">Select kitchen arrangement...</option>
          <option value="open_plan">Open-plan</option>
          <option value="semi_open">Semi-open</option>
          <option value="separate">Separate</option>
        </select>
      </div>

      <div class="form-group">
        <label for="livingSpaces">Living Spaces *</label>
        <select id="livingSpaces" name="livingSpaces" required>
          <option value="">Select living spaces...</option>
          <option value="single_main_space">Single main space</option>
          <option value="multiple_living_areas">Multiple living areas</option>
        </select>
      </div>

      <div class="form-row">
        <div class="form-group">
          <label for="roofType">Roof Type *</label>
          <select id="roofType" name="roofType" required>
            <option value="">Select roof type...</option>
            <option value="flat">Flat</option>
            <option value="pitched">Pitched</option>
            <option value="mixed">Mixed</option>
          </select>
        </div>

        <div class="form-group">
          <label for="massingPreference">Massing Preference *</label>
          <select id="massingPreference" name="massingPreference" required>
            <option value="">Select massing preference...</option>
            <option value="split_volumes">Split volumes</option>
            <option value="stepped">Stepped</option>
            <option value="simple_compact">Simple/compact</option>
            <option value="linear_elongated">Linear/elongated</option>
            <option value="courtyard">Courtyard</option>
            <option value="vertical_tall">Vertical/Tall</option>
          </select>
        </div>
      </div>

      <div class="form-row" id="orientation-group" style="display: none;">
        <div class="form-group">
          <label for="orientation">Proposed Orientation</label>
          <select id="orientation" name="orientation">
            <option value="">Select orientation...</option>
            <option value="north_facing_rear">North-facing rear</option>
            <option value="south_facing_rear">South-facing rear</option>
            <option value="east">East</option>
            <option value="west">West</option>
          </select>
        </div>
      </div>

      <div class="form-group">
        <label for="outputType">Output Type *</label>
        <select id="outputType" name="outputType" required>
          <option value="">Select output type...</option>
          <option value="concept_axonometric">Concept Axonometric</option>
          <option value="concept_plan">Isometric Plan (Cutaway)</option>
          <option value="concept_section">Concept Section</option>
        </select>
      </div>

      <div class="form-group">
        <label for="conceptRange">Concept Range *</label>
        <select id="conceptRange" name="conceptRange" required>
          <option value="Grounded">Grounded (default - constraint-led, planning-conscious)</option>
          <option value="Exploratory">Exploratory (testing alternatives, pushing forms)</option>
          <option value="Speculative">Speculative (bold, exaggerated, conceptual)</option>
        </select>
      </div>

      <!-- Concept Status Indicator -->
      <div id="concept-status-indicator" style="display: none; margin-top: 15px; padding: 12px; border-radius: 4px; font-size: 14px;">
        <div id="concept-status-active" style="display: none;">
          <strong style="color: #2e7d32;">✓ Active Concept:</strong> <span id="concept-status-id" style="font-family: monospace; font-size: 13px;"></span>
          <p style="margin: 5px 0 0 0; font-size: 13px; color: #2e7d32;">You can generate correlated isometric plan and section views using this concept.</p>
        </div>
        <div id="concept-status-warning" style="display: none;">
          <strong style="color: #2196f3;">ℹ️ Standalone Generation</strong>
          <p style="margin: 5px 0 0 0; font-size: 13px; color: #2196f3;">You can generate isometric plan/section views independently. A new concept will be created automatically if needed.</p>
        </div>
      </div>

      <div class="section-divider"></div>

      <button type="submit" id="submit-btn">Generate Rendering</button>
    </form>

    <div id="status" class="status"></div>

    <div id="result-container">
      <h2>Result</h2>
      
      <div class="prompt-section">
        <div class="prompt-header" id="prompt-header">
          <h3>Generated Prompt</h3>
          <span class="prompt-toggle" id="prompt-toggle">▼</span>
        </div>
        <div class="prompt-content" id="prompt-content">
          <pre class="prompt-text" id="prompt-text"></pre>
        </div>
      </div>

      <img id="result-image" alt="Generated rendering">
      <div class="result-info">
        <div><strong>Model:</strong> <span id="result-model"></span></div>
        <div><strong>Prompt Version:</strong> <span id="result-prompt-version"></span></div>
        <div><strong>Render Type:</strong> <span id="result-render-type"></span></div>
        <div id="result-concept-id" style="display: none;"><strong>Concept ID:</strong> <span id="result-concept-id-value"></span></div>
        <div id="result-concept-range" style="display: none;"><strong>Concept Range (locked):</strong> <span id="result-concept-range-value"></span></div>
      </div>

      <!-- Generate additional views (shown after axon is created) -->
      <div id="render-concept-actions" style="margin-top: 20px; padding: 15px; background: #e8f5e9; border-left: 4px solid #4caf50; border-radius: 4px; display: none;">
        <h4 style="margin: 0 0 10px 0; color: #2e7d32;">✓ Concept Created - Generate Correlated Views</h4>
        <p style="margin: 0 0 15px 0; font-size: 14px; color: #2e7d32;">Generate isometric plan and section views using the same concept seed for consistency.</p>
        
        <!-- View Options -->
        <div style="margin-bottom: 15px; padding: 12px; background: #f5f5f5; border-radius: 4px;">
          <h5 style="margin: 0 0 10px 0; font-size: 14px; color: #333;">View Options:</h5>
          <div style="display: flex; flex-direction: column; gap: 8px;">
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
              <input type="checkbox" id="people-in-plan" style="width: auto; margin: 0;">
              <span>People in isometric plan (cutaway)</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 14px;">
              <input type="checkbox" id="people-in-section" style="width: auto; margin: 0;">
              <span>People in section (isometric cutaway)</span>
            </label>
          </div>
        </div>
        
        <button type="button" id="render-generate-plan-btn" style="width: auto; display: inline-block; margin-right: 10px; margin-bottom: 10px;">Generate Isometric Plan (Cutaway)</button>
        <button type="button" id="render-generate-section-btn" style="width: auto; display: inline-block; margin-bottom: 10px;">Generate Section (isometric cutaway)</button>
        <div id="render-plan-result" style="margin-top: 15px;"></div>
        <div id="render-section-result" style="margin-top: 15px;"></div>
      </div>
    </div>
  </div>

  <script>
    const form = document.getElementById('render-form');
    const submitBtn = document.getElementById('submit-btn');
    const status = document.getElementById('status');
    const resultContainer = document.getElementById('result-container');
    const resultImage = document.getElementById('result-image');
    const resultModel = document.getElementById('result-model');
    const resultPromptVersion = document.getElementById('result-prompt-version');
    const resultRenderType = document.getElementById('result-render-type');
    const resultConceptId = document.getElementById('result-concept-id');
    const resultConceptIdValue = document.getElementById('result-concept-id-value');
    const resultConceptRange = document.getElementById('result-concept-range');
    const resultConceptRangeValue = document.getElementById('result-concept-range-value');
    const renderConceptActions = document.getElementById('render-concept-actions');
    const renderConceptSeedPanel = document.getElementById('render-concept-seed-panel');
    const renderConceptSeedJson = document.getElementById('render-concept-seed-json');
    const renderPlanResult = document.getElementById('render-plan-result');
    const renderSectionResult = document.getElementById('render-section-result');
    const renderGeneratePlanBtn = document.getElementById('render-generate-plan-btn');
    const renderGenerateSectionBtn = document.getElementById('render-generate-section-btn');
    const promptText = document.getElementById('prompt-text');
    const promptHeader = document.getElementById('prompt-header');
    const promptContent = document.getElementById('prompt-content');
    const promptToggle = document.getElementById('prompt-toggle');
    // API URL configuration:
    // - On localhost: use http://localhost:3001 (local dev server)
    // - On deployed (Vercel): use same origin (empty string = relative URLs)
    // Default to same origin (relative URLs) unless explicitly on localhost
    const hostname = window.location.hostname || window.location.host || '';
    const isLocalhost = hostname === 'localhost' || hostname === '127.0.0.1' || hostname.startsWith('localhost:');
    // Only use localhost URL if we're explicitly on localhost, otherwise use same origin
    const API_URL = (hostname === 'localhost' || hostname === '127.0.0.1') ? 'http://localhost:3001' : '';
    
    // Debug logging to help diagnose issues
    console.log('API configuration:', { 
      hostname, 
      origin: window.location.origin,
      isLocalhost, 
      API_URL: API_URL || '(same origin)' 
    });

    // Store current concept state
    let currentConceptId = null;
    let currentProjectId = null;

    // Concept status indicator elements
    const conceptStatusIndicator = document.getElementById('concept-status-indicator');
    const conceptStatusActive = document.getElementById('concept-status-active');
    const conceptStatusWarning = document.getElementById('concept-status-warning');
    const conceptStatusId = document.getElementById('concept-status-id');
    const outputTypeSelect = document.getElementById('outputType');

    // Update concept status indicator based on output type and current concept
    function updateConceptStatusIndicator() {
      const outputType = outputTypeSelect.value;
      const needsConcept = outputType === 'concept_plan' || outputType === 'concept_section';
      
      if (needsConcept) {
        conceptStatusIndicator.style.display = 'block';
        if (currentConceptId) {
          // Active concept exists - show success state
          conceptStatusActive.style.display = 'block';
          conceptStatusWarning.style.display = 'none';
          conceptStatusId.textContent = currentConceptId;
          conceptStatusIndicator.style.background = '#e8f5e9';
          conceptStatusIndicator.style.borderLeft = '4px solid #4caf50';
        } else {
          // No active concept - show info that standalone generation is possible
          conceptStatusActive.style.display = 'none';
          conceptStatusWarning.style.display = 'block';
          conceptStatusIndicator.style.background = '#e3f2fd';
          conceptStatusIndicator.style.borderLeft = '4px solid #2196f3';
        }
      } else {
        conceptStatusIndicator.style.display = 'none';
      }
    }

    // Listen for output type changes
    outputTypeSelect.addEventListener('change', updateConceptStatusIndicator);

    // Site location elements
    const addressInput = document.getElementById('address');
    const lookupBtn = document.getElementById('lookup-btn');
    const locationDisplay = document.getElementById('location-display');
    const locationName = document.getElementById('location-name');
    const baselineSummary = document.getElementById('baseline-summary');
    const baselineDetails = document.getElementById('baseline-details');
    const candidateSelector = document.getElementById('candidate-selector');
    const candidateButtons = document.getElementById('candidate-buttons');
    const baselineOverrides = document.getElementById('baseline-overrides');
    const footprintConfirmation = document.getElementById('footprint-confirmation');
    const footprintMapContainer = document.getElementById('footprint-map-container');
    const footprintConfidenceBadge = document.getElementById('footprint-confidence-badge');
    const confirmFootprintBtn = document.getElementById('confirm-footprint-btn');
    
    // Store site lookup data
    let siteContextSummary = null;
    let geocodeResult = null;
    let siteLookupResult = null;
    let selectedBuildingId = null;
    /** When confidence is Low: null = primary selected, number = candidate id selected. Set on map click; committed on Confirm. */
    let pendingFootprintSelection = null;

    function drawFootprintMap(primaryPolygon, neighbourPolygons, container, options) {
      if (!primaryPolygon || primaryPolygon.length < 3) return;
      const candidates = (options && options.candidates) ? options.candidates.slice(0, 3) : [];
      const selectedId = options && options.selectedId !== undefined ? options.selectedId : null;
      const onSelect = options && options.onSelect ? options.onSelect : null;
      const isLowConfidence = candidates.length > 0 && onSelect;

      const allPoints = [...primaryPolygon];
      (neighbourPolygons || []).forEach(function (n) {
        if (n.polygon) n.polygon.forEach(function (p) { allPoints.push(Array.isArray(p) ? p : [p.lat, p.lng]); });
      });
      let minLat = allPoints[0][0], maxLat = allPoints[0][0], minLng = allPoints[0][1], maxLng = allPoints[0][1];
      allPoints.forEach(function (p) {
        const lat = p[0], lng = p[1];
        if (lat < minLat) minLat = lat;
        if (lat > maxLat) maxLat = lat;
        if (lng < minLng) minLng = lng;
        if (lng > maxLng) maxLng = lng;
      });
      const pad = 0.15;
      const rangeLat = (maxLat - minLat) || 0.0001;
      const rangeLng = (maxLng - minLng) || 0.0001;
      minLat -= rangeLat * pad;
      maxLat += rangeLat * pad;
      minLng -= rangeLng * pad;
      maxLng += rangeLng * pad;
      const w = 600;
      const h = 280;
      function project(lat, lng) {
        const x = ((lng - minLng) / (maxLng - minLng)) * w;
        const y = (1 - (lat - minLat) / (maxLat - minLat)) * h;
        return [x, y];
      }
      function pathD(points) {
        if (!points || points.length < 2) return '';
        const start = project(points[0][0], points[0][1]);
        let d = 'M ' + start[0] + ' ' + start[1];
        for (let i = 1; i < points.length; i++) {
          const pt = project(points[i][0], points[i][1]);
          d += ' L ' + pt[0] + ' ' + pt[1];
        }
        return d + ' Z';
      }
      const candidateIds = new Set(candidates.map(function (c) { return c.id; }));
      function addPath(points, buildingId, isSelected) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', pathD(points));
        if (buildingId === 'primary') {
          path.setAttribute('fill', isSelected ? 'rgba(33, 150, 243, 0.5)' : 'rgba(33, 150, 243, 0.35)');
          path.setAttribute('stroke', '#1565c0');
        } else {
          path.setAttribute('fill', isSelected ? 'rgba(33, 150, 243, 0.5)' : '#e0e0e0');
          path.setAttribute('stroke', isSelected ? '#1565c0' : '#bdbdbd');
        }
        path.setAttribute('stroke-width', isSelected ? '2.5' : '1');
        path.setAttribute('data-building-id', buildingId === 'primary' ? 'primary' : String(buildingId));
        if (isLowConfidence) {
          path.style.cursor = 'pointer';
          path.addEventListener('click', function () {
            onSelect(buildingId === 'primary' ? null : buildingId);
          });
        }
        svg.appendChild(path);
      }

      const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
      svg.setAttribute('viewBox', '0 0 ' + w + ' ' + h);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', '100%');
      svg.style.display = 'block';

      (neighbourPolygons || []).forEach(function (n) {
        if (!n.polygon || n.polygon.length < 3) return;
        if (candidateIds.has(n.id)) return;
        const poly = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        poly.setAttribute('d', pathD(n.polygon));
        poly.setAttribute('fill', '#e0e0e0');
        poly.setAttribute('stroke', '#bdbdbd');
        poly.setAttribute('stroke-width', '1');
        svg.appendChild(poly);
      });

      candidates.forEach(function (c) {
        const np = (neighbourPolygons || []).find(function (n) { return n.id === c.id; });
        if (!np || !np.polygon || np.polygon.length < 3) return;
        addPath(np.polygon, c.id, selectedId === c.id);
      });
      addPath(primaryPolygon, 'primary', selectedId === null);
      container.innerHTML = '';
      container.appendChild(svg);
    }

    function redrawFootprintMapForSelection() {
      if (!siteLookupResult) return;
      const primary = siteLookupResult.primary;
      if (!primary.footprintPolygon || primary.footprintPolygon.length < 3) return;
      drawFootprintMap(
        primary.footprintPolygon,
        siteLookupResult.neighbourPolygons || [],
        footprintMapContainer,
        {
          candidates: siteLookupResult.candidates || [],
          selectedId: pendingFootprintSelection,
          onSelect: function (id) {
            pendingFootprintSelection = id;
            redrawFootprintMapForSelection();
          }
        }
      );
    }

    function showBaselineFromLookup(lookupData) {
      const primary = lookupData.primary;
      const baselineParts = [];
      if (primary.buildingForm !== 'Unknown') baselineParts.push('<strong>Form:</strong> ' + primary.buildingForm);
      if (primary.storeys !== 'Unknown') baselineParts.push('<strong>Storeys:</strong> ' + primary.storeys);
      if (primary.footprintScale !== 'Unknown') baselineParts.push('<strong>Scale:</strong> ' + primary.footprintScale + ' (' + Math.round(primary.footprintAreaM2) + ' m²)');
      baselineParts.push('<strong>Confidence:</strong> ' + primary.confidence);
      baselineDetails.innerHTML = baselineParts.join(' • ');
      const baselineSelectedEl = document.getElementById('baseline-selected-footprint');
      if (baselineSelectedEl) {
        if (selectedBuildingId != null) {
          baselineSelectedEl.style.display = 'block';
          baselineSelectedEl.textContent = 'Selected footprint: Building ' + selectedBuildingId + ' — used for cost estimation and rendering.';
        } else {
          baselineSelectedEl.style.display = 'none';
          baselineSelectedEl.textContent = '';
        }
      }
      const baselineDisclaimer = document.getElementById('baseline-disclaimer');
      if (baselineDisclaimer && lookupData.disclaimer) baselineDisclaimer.textContent = lookupData.disclaimer;
      baselineSummary.style.display = 'block';
      if (lookupData.candidates && lookupData.candidates.length > 0) {
        candidateButtons.innerHTML = '';
        lookupData.candidates.forEach(function (candidate) {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.style.cssText = 'width: 100%; margin: 0; text-align: left; padding: 10px; background: white; border: 1px solid #ddd; border-radius: 4px; cursor: pointer;';
          btn.innerHTML = '<div style="display: flex; justify-content: space-between; align-items: center;"><span><strong>Building ' + candidate.id + '</strong> - ' + candidate.distanceM + 'm away (' + candidate.confidence + ' confidence)</span>' + (selectedBuildingId === candidate.id ? '<span style="color: #4caf50;">✓ Selected</span>' : '') + '</div>';
          btn.addEventListener('click', function () {
            selectedBuildingId = candidate.id;
            candidateButtons.querySelectorAll('button').forEach(function (b) {
              b.style.border = '1px solid #ddd';
              b.style.background = 'white';
              var btnText = b.querySelector('span');
              if (btnText && btnText.textContent) btnText.innerHTML = btnText.innerHTML.replace(new RegExp('<span[^>]*>✓ Selected<\\/span>'), '');
            });
            btn.style.border = '2px solid #4caf50';
            btn.style.background = '#e8f5e9';
            var btnContent = btn.querySelector('div');
            if (btnContent) btnContent.innerHTML = '<span><strong>Building ' + candidate.id + '</strong> - ' + candidate.distanceM + 'm away (' + candidate.confidence + ' confidence)</span><span style="color: #4caf50;">✓ Selected</span>';
            var selEl = document.getElementById('baseline-selected-footprint');
            if (selEl) { selEl.style.display = 'block'; selEl.textContent = 'Selected footprint: Building ' + candidate.id + ' — used for cost estimation and rendering.'; }
            showStatus('Selected building ' + candidate.id + '. This will be used as the primary baseline.', 'success');
            setTimeout(hideStatus, 3000);
          });
          candidateButtons.appendChild(btn);
        });
        candidateSelector.style.display = 'block';
      }
      baselineOverrides.style.display = primary.confidence === 'Low' ? 'block' : 'none';
      var advWrap = document.getElementById('advanced-options-wrap');
      var advContent = document.getElementById('advanced-options-content');
      var advIcon = document.getElementById('advanced-options-toggle-icon');
      if (advWrap) advWrap.style.display = 'block';
      if (primary.confidence === 'Low') {
        if (advContent) advContent.style.display = 'block';
        if (advIcon) advIcon.style.transform = 'rotate(-180deg)';
      } else {
        if (advContent) advContent.style.display = 'none';
        if (advIcon) advIcon.style.transform = '';
      }
    }

    // Preset scenarios
    const presetSelect = document.getElementById('preset-select');
    
    const presets = {
      'suburban-extension': {
        projectType: 'extension',
        existingDensity: 'suburban',
        storeys: 'two',
        numberOfPlots: 'one',
        floorAreaRange: '100_150',
        footprintScale: 'medium',
        bedrooms: 'three',
        bathrooms: 'two',
        kitchenType: 'open_plan',
        livingSpaces: 'single_main_space',
        roofType: 'pitched',
        massingPreference: 'simple_compact',
        outputType: 'concept_axonometric',
      },
      'urban-infill': {
        projectType: 'new_build',
        existingDensity: '',
        storeys: 'three_plus',
        numberOfPlots: 'one',
        totalFloorAreaRange: '100_150',
        footprintScale: 'compact',
        bedrooms: 'two',
        bathrooms: 'one',
        kitchenType: 'open_plan',
        livingSpaces: 'single_main_space',
        roofType: 'flat',
        massingPreference: 'vertical_tall',
        outputType: 'concept_axonometric',
      },
      'rural-conversion': {
        projectType: 'renovation',
        existingDensity: 'rural',
        storeys: 'two',
        numberOfPlots: 'one',
        renovationScope: 'Deep retrofit',
        bedrooms: 'three',
        bathrooms: 'two',
        kitchenType: 'semi_open',
        livingSpaces: 'multiple_living_areas',
        roofType: 'mixed',
        massingPreference: 'simple_compact',
        outputType: 'concept_axonometric',
      },
      'suburban-renovation': {
        projectType: 'renovation',
        existingDensity: 'suburban',
        storeys: 'two',
        numberOfPlots: 'one',
        renovationScope: 'Reconfigure layout',
        bedrooms: 'three',
        bathrooms: 'two',
        kitchenType: 'open_plan',
        livingSpaces: 'single_main_space',
        roofType: 'pitched',
        massingPreference: 'simple_compact',
        outputType: 'concept_axonometric',
      },
      'urban-terrace-refresh': {
        projectType: 'renovation',
        existingDensity: 'urban',
        storeys: 'two',
        numberOfPlots: 'one',
        renovationScope: 'Light refresh',
        bedrooms: 'two',
        bathrooms: 'one',
        kitchenType: 'semi_open',
        livingSpaces: 'multiple_living_areas',
        roofType: 'pitched',
        massingPreference: 'simple_compact',
        outputType: 'concept_axonometric',
      },
      'compare-grounded': {
        projectType: 'new_build',
        storeys: 'two',
        numberOfPlots: 'one',
        totalFloorAreaRange: '100_150',
        footprintScale: 'medium',
        bedrooms: 'three',
        bathrooms: 'two',
        kitchenType: 'open_plan',
        livingSpaces: 'single_main_space',
        roofType: 'pitched',
        massingPreference: 'simple_compact',
        outputType: 'concept_axonometric',
        conceptRange: 'Grounded',
      },
      'compare-exploratory': {
        projectType: 'new_build',
        storeys: 'two',
        numberOfPlots: 'one',
        totalFloorAreaRange: '100_150',
        footprintScale: 'medium',
        bedrooms: 'three',
        bathrooms: 'two',
        kitchenType: 'open_plan',
        livingSpaces: 'single_main_space',
        roofType: 'pitched',
        massingPreference: 'simple_compact',
        outputType: 'concept_axonometric',
        conceptRange: 'Exploratory',
      },
      'compare-speculative': {
        projectType: 'new_build',
        storeys: 'two',
        numberOfPlots: 'one',
        totalFloorAreaRange: '100_150',
        footprintScale: 'medium',
        bedrooms: 'three',
        bathrooms: 'two',
        kitchenType: 'open_plan',
        livingSpaces: 'single_main_space',
        roofType: 'pitched',
        massingPreference: 'simple_compact',
        outputType: 'concept_axonometric',
        conceptRange: 'Speculative',
      },
    };

    // Load preset into form
    presetSelect.addEventListener('change', (e) => {
      const presetKey = e.target.value;
      if (!presetKey || !presets[presetKey]) {
        return;
      }

      const preset = presets[presetKey];
      
      // Populate form fields
      if (preset.projectType) {
        document.getElementById('projectType').value = preset.projectType;
        // Trigger update to show/hide fields based on project type
        updateExistingContextInputs();
      }
      if (preset.existingDensity) document.getElementById('existingDensity').value = preset.existingDensity;
      if (preset.projectType === 'new_build' && preset.storeys) document.getElementById('storeys').value = preset.storeys;
      if (preset.projectType === 'new_build' && preset.numberOfPlots) document.getElementById('numberOfPlots').value = preset.numberOfPlots;
      if (preset.projectType === 'new_build' && preset.orientation) document.getElementById('orientation').value = preset.orientation;
      
      // Handle floor area fields based on project type
      if (preset.projectType === 'new_build' && preset.totalFloorAreaRange) {
        document.getElementById('totalFloorAreaRange').value = preset.totalFloorAreaRange;
      } else if (preset.projectType === 'extension' && preset.additionalFloorAreaRange) {
        document.getElementById('additionalFloorAreaRange').value = preset.additionalFloorAreaRange;
      } else if (preset.floorAreaRange) {
        document.getElementById('floorAreaRange').value = preset.floorAreaRange;
      }
      
      // Handle extension/renovation specific fields
      if (preset.extensionType) document.getElementById('extensionType').value = preset.extensionType;
      if (preset.renovationScope) document.getElementById('renovationScope').value = preset.renovationScope;
      if (preset.footprintScale) document.getElementById('footprintScale').value = preset.footprintScale;
      if (preset.bedrooms) document.getElementById('bedrooms').value = preset.bedrooms;
      if (preset.bathrooms) document.getElementById('bathrooms').value = preset.bathrooms;
      if (preset.kitchenType) document.getElementById('kitchenType').value = preset.kitchenType;
      if (preset.livingSpaces) document.getElementById('livingSpaces').value = preset.livingSpaces;
      if (preset.roofType) document.getElementById('roofType').value = preset.roofType;
      if (preset.massingPreference) document.getElementById('massingPreference').value = preset.massingPreference;
      if (preset.outputType) document.getElementById('outputType').value = preset.outputType;
      if (preset.conceptRange) document.getElementById('conceptRange').value = preset.conceptRange;

      // Trigger existing context visibility update
      updateExistingContextInputs();
      
      // Show success message
      showStatus(`Loaded preset: ${presetSelect.options[presetSelect.selectedIndex].text}`, 'success');
      setTimeout(() => hideStatus(), 3000);
    });

    // Handle existing context inputs visibility/disabled state based on project type
    const projectTypeSelect = document.getElementById('projectType');
    const existingOrientation = document.getElementById('existingOrientation');
    const existingDensity = document.getElementById('existingDensity');

    // Track which fields are auto-populated
    let autoPopulatedFields = new Set();

    function updateExistingContextInputs() {
      const projectType = projectTypeSelect.value;
      const isNewBuild = projectType === 'new_build';
      const isRenovation = projectType === 'renovation';
      const isExtension = projectType === 'extension';
      
      // Handle existing context fields visibility
      const existingBuildingContent = document.getElementById('existing-building-content');
      if (isNewBuild) {
        // Hide existing building section for new builds
        if (existingBuildingContent) {
          existingBuildingContent.style.display = 'none';
        }
        existingOrientation.disabled = true;
        existingDensity.disabled = true;
        existingOrientation.value = '';
        existingDensity.value = '';
        document.getElementById('existingOrientation-estimated').style.display = 'none';
        document.getElementById('existingDensity-estimated').style.display = 'none';
        autoPopulatedFields.clear();
      } else {
        // Show existing building section for extension or renovation
        if (existingBuildingContent) {
          existingBuildingContent.style.display = 'block';
        }
        existingOrientation.disabled = false;
        existingDensity.disabled = false;
      }
      
      // Handle renovation-specific fields
      const renovationScopeGroup = document.getElementById('renovationScope-group');
      const renovationScopeSelect = document.getElementById('renovationScope');
      if (isRenovation) {
        renovationScopeGroup.style.display = 'block';
        renovationScopeSelect.required = true;
      } else {
        renovationScopeGroup.style.display = 'none';
        renovationScopeSelect.required = false;
        renovationScopeSelect.value = '';
      }
      
      // Handle extension-specific fields
      const extensionTypeGroup = document.getElementById('extensionType-group');
      const additionalFloorAreaRangeGroup = document.getElementById('additionalFloorAreaRange-group');
      const extensionTypeSelect = document.getElementById('extensionType');
      const additionalFloorAreaRangeSelect = document.getElementById('additionalFloorAreaRange');
      if (isExtension) {
        extensionTypeGroup.style.display = 'block';
        additionalFloorAreaRangeGroup.style.display = 'block';
        extensionTypeSelect.required = true;
        additionalFloorAreaRangeSelect.required = true;
      } else {
        extensionTypeGroup.style.display = 'none';
        additionalFloorAreaRangeGroup.style.display = 'none';
        extensionTypeSelect.required = false;
        additionalFloorAreaRangeSelect.required = false;
        extensionTypeSelect.value = '';
        additionalFloorAreaRangeSelect.value = '';
      }
      
      // Handle floor area range fields
      const floorAreaRangeGroup = document.getElementById('floorAreaRange-group');
      const totalFloorAreaRangeGroup = document.getElementById('totalFloorAreaRange-group');
      const floorAreaRangeSelect = document.getElementById('floorAreaRange');
      const totalFloorAreaRangeSelect = document.getElementById('totalFloorAreaRange');
      
      if (isNewBuild) {
        // New Build: show totalFloorAreaRange, hide floorAreaRange
        floorAreaRangeGroup.style.display = 'none';
        totalFloorAreaRangeGroup.style.display = 'block';
        floorAreaRangeSelect.required = false;
        totalFloorAreaRangeSelect.required = true;
        floorAreaRangeSelect.value = '';
      } else if (isExtension) {
        // Extension: show additionalFloorAreaRange (already handled above), hide others
        floorAreaRangeGroup.style.display = 'none';
        totalFloorAreaRangeGroup.style.display = 'none';
        floorAreaRangeSelect.required = false;
        totalFloorAreaRangeSelect.required = false;
        floorAreaRangeSelect.value = '';
        totalFloorAreaRangeSelect.value = '';
      } else if (isRenovation) {
        // Renovation: hide all floor area fields
        floorAreaRangeGroup.style.display = 'none';
        totalFloorAreaRangeGroup.style.display = 'none';
        floorAreaRangeSelect.required = false;
        totalFloorAreaRangeSelect.required = false;
        floorAreaRangeSelect.value = '';
        totalFloorAreaRangeSelect.value = '';
      } else {
        // Conversion: show floorAreaRange, hide totalFloorAreaRange
        floorAreaRangeGroup.style.display = 'block';
        totalFloorAreaRangeGroup.style.display = 'none';
        floorAreaRangeSelect.required = true;
        totalFloorAreaRangeSelect.required = false;
        totalFloorAreaRangeSelect.value = '';
      }

      // Number of storeys, number of plots, proposed orientation: only for New Build
      // Extension/Renovation: existing storeys from site/footprint (baseline) with override
      const storeysGroup = document.getElementById('storeys-group');
      const storeysSelect = document.getElementById('storeys');
      const numberOfPlotsGroup = document.getElementById('numberOfPlots-group');
      const numberOfPlotsSelect = document.getElementById('numberOfPlots');
      const orientationGroup = document.getElementById('orientation-group');
      const orientationSelect = document.getElementById('orientation');
      if (isNewBuild) {
        storeysGroup.style.display = 'flex';
        storeysSelect.required = true;
        numberOfPlotsGroup.style.display = 'flex';
        numberOfPlotsSelect.required = true;
        orientationGroup.style.display = 'flex';
      } else {
        storeysGroup.style.display = 'none';
        storeysSelect.required = false;
        storeysSelect.value = '';
        numberOfPlotsGroup.style.display = 'none';
        numberOfPlotsSelect.required = false;
        numberOfPlotsSelect.value = '';
        orientationGroup.style.display = 'none';
        orientationSelect.value = '';
      }
    }

    // Hide estimated label when user manually changes a field
    existingOrientation.addEventListener('change', function() {
      if (autoPopulatedFields.has('existingOrientation')) {
        document.getElementById('existingOrientation-estimated').style.display = 'none';
        autoPopulatedFields.delete('existingOrientation');
      }
    });

    existingDensity.addEventListener('change', function() {
      if (autoPopulatedFields.has('existingDensity')) {
        document.getElementById('existingDensity-estimated').style.display = 'none';
        autoPopulatedFields.delete('existingDensity');
      }
    });

    // Listen for project type changes
    projectTypeSelect.addEventListener('change', updateExistingContextInputs);
    
    // Initialize on page load
    updateExistingContextInputs();

    // Handle address lookup
    lookupBtn.addEventListener('click', async () => {
      const address = addressInput.value.trim();
      if (!address) {
        showStatus('Please enter an address or postcode', 'error');
        return;
      }

      lookupBtn.disabled = true;
      showStatus('Checking feasibility', 'info');
      locationDisplay.style.display = 'none';
      footprintConfirmation.style.display = 'none';
      baselineSummary.style.display = 'none';
      candidateSelector.style.display = 'none';
      baselineOverrides.style.display = 'none';
      var advWrap = document.getElementById('advanced-options-wrap');
      if (advWrap) advWrap.style.display = 'none';
      siteContextSummary = null;
      geocodeResult = null;
      siteLookupResult = null;
      selectedBuildingId = null;
      pendingFootprintSelection = null;

      try {
        // Call site-lookup API
        const lookupResponse = await fetch(`${API_URL}/api/site-lookup`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ query: address }),
        });

        if (!lookupResponse.ok) {
          const error = await lookupResponse.json();
          throw new Error(error.error || 'Site lookup failed');
        }

        const lookupData = await lookupResponse.json();
        siteLookupResult = lookupData;
        geocodeResult = {
          lat: lookupData.lat,
          lng: lookupData.lng,
          displayName: lookupData.displayName,
        };
        
        // Display location name
        locationName.textContent = lookupData.displayName;
        locationDisplay.style.display = 'block';

        const primary = lookupData.primary;
        const hasFootprint = primary.footprintPolygon && primary.footprintPolygon.length >= 3;

        if (hasFootprint) {
          footprintConfidenceBadge.textContent = primary.confidence;
          footprintConfidenceBadge.className = 'footprint-confidence-badge ' + (primary.confidence || '').toLowerCase();
          const footprintMessageEl = document.getElementById('footprint-confirmation-message');
          const isLowConfidence = primary.confidence === 'Low' && lookupData.candidates && lookupData.candidates.length > 0;
          if (isLowConfidence) {
            pendingFootprintSelection = null;
            if (footprintMessageEl) footprintMessageEl.textContent = "We found several buildings nearby. Click the footprint that matches your building.";
            redrawFootprintMapForSelection();
          } else {
            if (footprintMessageEl) footprintMessageEl.textContent = "We've identified this building — please confirm it's correct.";
            drawFootprintMap(primary.footprintPolygon, lookupData.neighbourPolygons || [], footprintMapContainer);
          }
          footprintConfirmation.style.display = 'block';
        } else {
          // No footprint to confirm — show baseline summary directly
          showBaselineFromLookup(lookupData);
        }

        showStatus('Site lookup completed successfully!', 'success');
      } catch (error) {
        console.error('Lookup error:', error);
        showStatus(`Error: ${error.message}`, 'error');
        locationDisplay.style.display = 'none';
        footprintConfirmation.style.display = 'none';
        baselineSummary.style.display = 'none';
        candidateSelector.style.display = 'none';
        baselineOverrides.style.display = 'none';
        var advWrapErr = document.getElementById('advanced-options-wrap');
        if (advWrapErr) advWrapErr.style.display = 'none';
        geocodeResult = null;
        siteLookupResult = null;
      } finally {
        lookupBtn.disabled = false;
      }
    });

    confirmFootprintBtn.addEventListener('click', function () {
      if (!siteLookupResult) return;
      selectedBuildingId = pendingFootprintSelection != null ? pendingFootprintSelection : null;
      footprintConfirmation.style.display = 'none';
      showBaselineFromLookup(siteLookupResult);
      showStatus(selectedBuildingId != null
        ? 'Footprint locked. Building ' + selectedBuildingId + ' will be used for cost estimation and rendering.'
        : 'Footprint confirmed. You can choose another building below if needed.', 'success');
      setTimeout(hideStatus, 4000);
    });

    var advancedOptionsToggle = document.getElementById('advanced-options-toggle');
    var advancedOptionsContent = document.getElementById('advanced-options-content');
    var advancedOptionsIcon = document.getElementById('advanced-options-toggle-icon');
    if (advancedOptionsToggle && advancedOptionsContent) {
      advancedOptionsToggle.addEventListener('click', function () {
        var isOpen = advancedOptionsContent.style.display === 'block';
        advancedOptionsContent.style.display = isOpen ? 'none' : 'block';
        if (advancedOptionsIcon) advancedOptionsIcon.style.transform = isOpen ? '' : 'rotate(-180deg)';
      });
    }

    // Toggle prompt visibility
    promptHeader.addEventListener('click', () => {
      const isExpanded = promptContent.classList.contains('show');
      if (isExpanded) {
        promptContent.classList.remove('show');
        promptToggle.classList.remove('expanded');
      } else {
        promptContent.classList.add('show');
        promptToggle.classList.add('expanded');
      }
    });

    // Helper function to convert file to base64
    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => {
          // Remove data URL prefix (e.g., "data:image/png;base64,")
          const base64 = reader.result.split(',')[1];
          resolve(base64);
        };
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function getConstructaOSLoadingHTML(message) {
      return `<div class="constructaos-loading">
        <div class="constructaos-loading-line"></div>
        <div class="constructaos-loading-brand">ConstructaOS</div>
        <div class="constructaos-loading-message">${message}</div>
      </div>`;
    }

    function showStatus(message, type = 'info') {
      status.className = `status ${type}`;
      if (type === 'info') {
        status.innerHTML = getConstructaOSLoadingHTML(message);
        status.style.display = 'block';
      } else {
        status.textContent = message;
        status.style.display = 'block';
      }
    }

    function hideStatus() {
      status.className = 'status';
      status.textContent = '';
      status.innerHTML = '';
      status.style.display = 'none';
    }

    function showResult(data) {
      // Hide prompt section (not available in new API)
      promptContent.classList.remove('show');
      promptToggle.classList.remove('expanded');

      // Display rendered image
      resultImage.src = data.imageDataUrl || data.imageUrl;
      resultPromptVersion.textContent = data.promptVersion;
      
      // Format renderType for display with view labels
      let renderTypeDisplay = 'N/A';
      if (data.renderType) {
        if (data.renderType === 'axonometric') {
          renderTypeDisplay = 'Axon';
        } else if (data.renderType === 'floor_plan') {
          renderTypeDisplay = 'Isometric Plan (Cutaway)';
        } else if (data.renderType === 'section') {
          renderTypeDisplay = 'Section (isometric cutaway)';
        } else {
          renderTypeDisplay = data.renderType.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
      }
      resultRenderType.textContent = renderTypeDisplay;

      // Show concept ID
      if (data.conceptId) {
        resultConceptIdValue.textContent = data.conceptId;
        resultConceptId.style.display = 'block';

        // Show concept range if available (locked from seed)
        if (data.conceptRange) {
          resultConceptRangeValue.textContent = data.conceptRange;
          resultConceptRange.style.display = 'block';
        } else {
          resultConceptRange.style.display = 'none';
        }

        // If axonometric output, enable plan/section generation
        if (data.renderType === 'axonometric') {
          renderConceptActions.style.display = 'block';
          renderGeneratePlanBtn.disabled = false;
          renderGenerateSectionBtn.disabled = false;
          // Clear previous plan/section results
          renderPlanResult.innerHTML = '';
          renderSectionResult.innerHTML = '';
        } else {
          // For plan/section outputs, hide the actions
          renderConceptActions.style.display = 'none';
        }
      } else {
        // No concept ID - hide concept-related UI
        resultConceptId.style.display = 'none';
        resultConceptRange.style.display = 'none';
        renderConceptActions.style.display = 'none';
      }

      resultContainer.classList.add('show');
    }

    function hideResult() {
      resultContainer.classList.remove('show');
      // Don't clear concept state - allow plan/section generation even after hiding result
      // But clear plan/section results
      if (renderPlanResult) renderPlanResult.innerHTML = '';
      if (renderSectionResult) renderSectionResult.innerHTML = '';
    }

    function showConceptStatus(message, type = 'info') {
      conceptStatus.textContent = message;
      conceptStatus.className = `status ${type}`;
    }

    function hideConceptStatus() {
      conceptStatus.className = 'status';
    }

    // Helper function to call /api/render for additional views
    async function callApiRender(renderType, projectId, conceptId, conceptBrief, options = {}) {
      const payload = {
        projectId: projectId,
        renderType: renderType,
        conceptInputs: conceptBrief,
        ...options, // Include any additional options (e.g., includePeopleInPlan, includePeopleInSection)
      };
      
      // Only include conceptId if it's provided (allows standalone generation)
      if (conceptId) {
        payload.conceptId = conceptId;
      }

      // Add selectedBuildingId if user selected a candidate
      if (selectedBuildingId) {
        payload.selectedBuildingId = selectedBuildingId;
      }

      // Add manual overrides if provided
      const overrideBuildingForm = document.getElementById('overrideBuildingForm').value;
      const overrideStoreys = document.getElementById('overrideStoreys').value;
      const overrideRoofAssumption = document.getElementById('overrideRoofAssumption').value;
      const overrideFootprintScale = document.getElementById('footprintScaleOverride') ? document.getElementById('footprintScaleOverride').value : '';
      
      if (overrideBuildingForm || overrideStoreys || overrideRoofAssumption || overrideFootprintScale) {
        payload.baselineOverrides = {};
        if (overrideBuildingForm) {
          payload.baselineOverrides.buildingForm = overrideBuildingForm;
        }
        if (overrideStoreys) {
          payload.baselineOverrides.storeys = overrideStoreys;
        }
        if (overrideRoofAssumption) {
          payload.baselineOverrides.roofAssumption = overrideRoofAssumption;
        }
        if (overrideFootprintScale) {
          payload.baselineOverrides.footprintScale = overrideFootprintScale;
        }
      }

      // Add address/latlng for site lookup if available
      if (geocodeResult) {
        payload.address = addressInput.value.trim();
        payload.lat = geocodeResult.lat;
        payload.lng = geocodeResult.lng;
      }

      const response = await fetch(`${API_URL}/api/render`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        const contentType = response.headers.get('content-type');
        let errorData = null;
        if (contentType && contentType.includes('application/json')) {
          errorData = await response.json();
        }
        throw { status: response.status, data: errorData };
      }

      return await response.json();
    }

    // Generate Plan (can be standalone or from existing concept)
    renderGeneratePlanBtn.addEventListener('click', async () => {
      // Get projectId - use currentProjectId if available, otherwise use default
      const projectId = currentProjectId || 'default';

      // Get the concept brief from the form
      const submitProjectType = document.getElementById('projectType').value;
      const submitIsNewBuild = submitProjectType === 'new_build';

      const proposedDesign = {
        projectType: submitProjectType,
        bedrooms: document.getElementById('bedrooms').value,
        bathrooms: document.getElementById('bathrooms').value,
        kitchenType: document.getElementById('kitchenType').value,
        livingSpaces: document.getElementById('livingSpaces').value,
        roofType: document.getElementById('roofType').value,
        massingPreference: document.getElementById('massingPreference').value,
        outputType: 'concept_plan',
      };
      if (submitIsNewBuild) {
        proposedDesign.storeys = document.getElementById('storeys').value;
        proposedDesign.numberOfPlots = document.getElementById('numberOfPlots').value;
        const orientation = document.getElementById('orientation').value;
        if (orientation) proposedDesign.orientation = orientation;
      }
      // Add project type-specific fields
      if (submitProjectType === 'new_build') {
        proposedDesign.totalFloorAreaRange = document.getElementById('totalFloorAreaRange').value;
      } else if (submitProjectType === 'extension') {
        proposedDesign.extensionType = document.getElementById('extensionType').value;
        proposedDesign.additionalFloorAreaRange = document.getElementById('additionalFloorAreaRange').value;
      } else if (submitProjectType === 'renovation') {
        proposedDesign.renovationScope = document.getElementById('renovationScope').value;
      }

      const conceptBrief = { proposedDesign };

      if (!submitIsNewBuild) {
        const existingOrientation = document.getElementById('existingOrientation').value;
        const existingDensity = document.getElementById('existingDensity').value;
        if (existingOrientation || existingDensity) {
          conceptBrief.existingContext = {};
          if (existingOrientation) conceptBrief.existingContext.orientation = existingOrientation;
          if (existingDensity) conceptBrief.existingContext.density = existingDensity;
        }
      }

      renderGeneratePlanBtn.disabled = true;
      renderPlanResult.innerHTML = '<p style="color: #666;">Generating isometric plan...</p>';

      // Get people toggle state
      const peopleInPlanCheckbox = document.getElementById('people-in-plan');
      const includePeopleInPlan = peopleInPlanCheckbox ? peopleInPlanCheckbox.checked : false;

      try {
        // Use currentConceptId if available, otherwise omit it to allow standalone generation
        const conceptId = currentConceptId && currentProjectId === projectId ? currentConceptId : null;
        const data = await callApiRender('floor_plan', projectId, conceptId, conceptBrief, {
          includePeopleInPlan: includePeopleInPlan,
        });
        
        // Update currentConceptId if we got one back (for standalone generation)
        if (data.conceptId && !currentConceptId) {
          currentConceptId = data.conceptId;
          currentProjectId = projectId;
          updateConceptStatusIndicator();
        }

        renderPlanResult.innerHTML = `
          <h4 style="margin-bottom: 10px;">Isometric Plan (Cutaway)</h4>
          <img src="${data.imageDataUrl || data.imageUrl}" alt="Isometric plan cutaway" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;">
          <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">v${data.promptVersion}</p>
        `;

        showStatus('Isometric plan generated successfully!', 'success');
      } catch (error) {
        console.error('Error generating plan:', error);
        renderPlanResult.innerHTML = `<p style="color: #f44336;">Error: ${error.data?.message || error.message || 'Failed to generate isometric plan'}</p>`;
      } finally {
        renderGeneratePlanBtn.disabled = false;
      }
    });

    // Generate Section from current concept
    renderGenerateSectionBtn.addEventListener('click', async () => {
      if (!currentConceptId || !currentProjectId) {
        showStatus('Please generate an axonometric view first', 'error');
        return;
      }

      // Get the concept brief from the form
      const submitProjectType = document.getElementById('projectType').value;
      const submitIsNewBuild = submitProjectType === 'new_build';

      const proposedDesign = {
        projectType: submitProjectType,
        bedrooms: document.getElementById('bedrooms').value,
        bathrooms: document.getElementById('bathrooms').value,
        kitchenType: document.getElementById('kitchenType').value,
        livingSpaces: document.getElementById('livingSpaces').value,
        roofType: document.getElementById('roofType').value,
        massingPreference: document.getElementById('massingPreference').value,
        outputType: 'concept_section',
      };
      if (submitIsNewBuild) {
        proposedDesign.storeys = document.getElementById('storeys').value;
        proposedDesign.numberOfPlots = document.getElementById('numberOfPlots').value;
        const orientation = document.getElementById('orientation').value;
        if (orientation) proposedDesign.orientation = orientation;
      }
      // Add project type-specific fields
      if (submitProjectType === 'new_build') {
        proposedDesign.totalFloorAreaRange = document.getElementById('totalFloorAreaRange').value;
      } else if (submitProjectType === 'extension') {
        proposedDesign.extensionType = document.getElementById('extensionType').value;
        proposedDesign.additionalFloorAreaRange = document.getElementById('additionalFloorAreaRange').value;
      } else if (submitProjectType === 'renovation') {
        proposedDesign.renovationScope = document.getElementById('renovationScope').value;
      }

      const conceptBrief = { proposedDesign };

      if (!submitIsNewBuild) {
        const existingOrientation = document.getElementById('existingOrientation').value;
        const existingDensity = document.getElementById('existingDensity').value;
        if (existingOrientation || existingDensity) {
          conceptBrief.existingContext = {};
          if (existingOrientation) conceptBrief.existingContext.orientation = existingOrientation;
          if (existingDensity) conceptBrief.existingContext.density = existingDensity;
        }
      }

      renderGenerateSectionBtn.disabled = true;
      renderSectionResult.innerHTML = getConstructaOSLoadingHTML('Generating concept');

      // Get people toggle state
      const peopleInSectionCheckbox = document.getElementById('people-in-section');
      const includePeopleInSection = peopleInSectionCheckbox ? peopleInSectionCheckbox.checked : false;

      try {
        const data = await callApiRender('section', currentProjectId, currentConceptId, conceptBrief, {
          includePeopleInSection: includePeopleInSection,
        });

        renderSectionResult.innerHTML = `
          <h4 style="margin-bottom: 10px;">Section (isometric cutaway)</h4>
          <img src="${data.imageDataUrl || data.imageUrl}" alt="Section view" style="max-width: 100%; height: auto; border: 1px solid #ddd; border-radius: 4px;">
          <p style="margin: 5px 0 0 0; font-size: 12px; color: #666;">v${data.promptVersion}</p>
        `;

        showStatus('Section generated successfully!', 'success');
      } catch (error) {
        console.error('Error generating section:', error);
        
        if (error.status === 409 && error.data?.error === 'AXON_REQUIRED') {
          renderSectionResult.innerHTML = `
            <div style="padding: 15px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
              <p style="margin: 0; color: #856404; font-weight: 600;">⚠️ Axon Required</p>
              <p style="margin: 8px 0 0 0; font-size: 13px; color: #856404;">${error.data.message}</p>
            </div>
          `;
        } else {
          renderSectionResult.innerHTML = `<p style="color: #f44336;">Error: ${error.data?.message || error.message || 'Failed to generate section'}</p>`;
        }
      } finally {
        renderGenerateSectionBtn.disabled = false;
      }
    });

    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      hideStatus();
      hideResult();

      const projectId = document.getElementById('projectId').value;

      if (!projectId) {
        showStatus('Please fill in all required fields', 'error');
        return;
      }

      // Collect all structured inputs as ConceptBrief
      const submitProjectType = document.getElementById('projectType').value;
      const submitIsNewBuild = submitProjectType === 'new_build';

      // Build proposedDesign based on projectType
      const proposedDesign = {
        projectType: submitProjectType,
        bedrooms: document.getElementById('bedrooms').value,
        bathrooms: document.getElementById('bathrooms').value,
        kitchenType: document.getElementById('kitchenType').value,
        livingSpaces: document.getElementById('livingSpaces').value,
        roofType: document.getElementById('roofType').value,
        massingPreference: document.getElementById('massingPreference').value,
        outputType: document.getElementById('outputType').value,
      };

      // Number of storeys, number of plots, proposed orientation: only for New Build
      // Extension/Renovation: existing storeys from site/footprint (baseline) with override
      if (submitIsNewBuild) {
        proposedDesign.storeys = document.getElementById('storeys').value;
        proposedDesign.numberOfPlots = document.getElementById('numberOfPlots').value;
        const orientation = document.getElementById('orientation').value;
        if (orientation) proposedDesign.orientation = orientation;
      }

      // Add projectType-specific fields
      if (submitProjectType === 'new_build') {
        proposedDesign.totalFloorAreaRange = document.getElementById('totalFloorAreaRange').value;
      } else if (submitProjectType === 'extension') {
        proposedDesign.extensionType = document.getElementById('extensionType').value;
        proposedDesign.additionalFloorAreaRange = document.getElementById('additionalFloorAreaRange').value;
      } else if (submitProjectType === 'renovation') {
        proposedDesign.renovationScope = document.getElementById('renovationScope').value;
      }

      // Add optional fields to proposedDesign
      if (submitProjectType !== 'renovation') {
        // Footprint scale not applicable for renovation
        const footprintScale = document.getElementById('footprintScale').value;
        if (footprintScale) {
          proposedDesign.footprintScale = footprintScale;
        }
      }

      // Build existingContext (only if not new build); building form is derived from baseline, not user input
      let existingContext = undefined;
      if (!submitIsNewBuild) {
        const existingOrientation = document.getElementById('existingOrientation').value;
        const existingDensity = document.getElementById('existingDensity').value;

        existingContext = {};
        if (existingOrientation) {
          existingContext.orientation = existingOrientation;
        }
        if (existingDensity) {
          existingContext.density = existingDensity;
        }
      }

      // Build ConceptBrief
      const conceptBrief = {
        proposedDesign: proposedDesign,
      };
      if (existingContext) {
        conceptBrief.existingContext = existingContext;
      }
      
      // Add conceptRange (only include for first render/axonometric)
      const conceptRange = document.getElementById('conceptRange').value;
      if (conceptRange) {
        conceptBrief.conceptRange = conceptRange;
      }

      // Build site context summary if we have geocode result but no summary yet
      if (geocodeResult && !siteContextSummary) {
        const hasRequiredFields = conceptBrief.proposedDesign.projectType && 
                                conceptBrief.proposedDesign.outputType;
          
          if (hasRequiredFields) {
            try {
              showStatus('Checking feasibility', 'info');
              const contextResponse = await fetch(`${API_URL}/api/build-site-context`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  lat: geocodeResult.lat,
                  lng: geocodeResult.lng,
                  displayName: geocodeResult.displayName,
                  conceptInputs: conceptBrief, // Server accepts both formats
                }),
              });

            if (contextResponse.ok) {
              const contextResult = await contextResponse.json();
              siteContextSummary = contextResult.siteContextSummary;
            }
          } catch (error) {
            console.warn('Failed to build site context on submit:', error);
            // Continue without site context if build fails
          }
        }
      }

      // Log conceptBrief to console
      console.log('Concept Brief:', conceptBrief);

      submitBtn.disabled = true;
      
      // Use job-based async pattern by default (free tier compatible)
      await handleJobBasedRender(projectId, conceptBrief, outputType);
    });

    // Helper function: Direct render (original approach)
    async function handleDirectRender(projectId, conceptBrief, outputType) {
      showStatus('Generating concept', 'info');

      try {
        // Map outputType to renderType
        const outputType = conceptBrief.proposedDesign.outputType;
        const renderTypeMap = {
          'concept_axonometric': 'axonometric',
          'concept_plan': 'floor_plan',
          'concept_section': 'section',
        };
        const renderType = renderTypeMap[outputType] || 'axonometric';

        const payload = {
          projectId: projectId,
          renderType: renderType,
          conceptInputs: conceptBrief,
        };

        // Add selectedBuildingId if user selected a candidate
        if (selectedBuildingId) {
          payload.selectedBuildingId = selectedBuildingId;
        }

        // Add manual overrides if provided
        const overrideBuildingForm = document.getElementById('overrideBuildingForm').value;
        const overrideStoreys = document.getElementById('overrideStoreys').value;
        const overrideRoofAssumption = document.getElementById('overrideRoofAssumption').value;
        const overrideFootprintScale = document.getElementById('footprintScaleOverride') ? document.getElementById('footprintScaleOverride').value : '';
        
        if (overrideBuildingForm || overrideStoreys || overrideRoofAssumption || overrideFootprintScale) {
          payload.baselineOverrides = {};
          if (overrideBuildingForm) {
            payload.baselineOverrides.buildingForm = overrideBuildingForm;
          }
          if (overrideStoreys) {
            payload.baselineOverrides.storeys = overrideStoreys;
          }
          if (overrideRoofAssumption) {
            payload.baselineOverrides.roofAssumption = overrideRoofAssumption;
          }
          if (overrideFootprintScale) {
            payload.baselineOverrides.footprintScale = overrideFootprintScale;
          }
        }

        // Add address/latlng for site lookup if available
        if (geocodeResult) {
          payload.address = addressInput.value.trim();
          payload.lat = geocodeResult.lat;
          payload.lng = geocodeResult.lng;
        }

        // Log payload before sending
        console.log('Request Payload:', payload);

        const response = await fetch(`${API_URL}/api/render`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        });

        if (!response.ok) {
          let errorMessage = `HTTP error! status: ${response.status}`;
          let errorDetails = null;
          try {
            const error = await response.json();
            errorMessage = error.message || error.error || errorMessage;
            errorDetails = error;
            
            // Special handling for timeout errors
            if (response.status === 503 && error.error === 'TIMEOUT_IMMINENT') {
              errorMessage = `⏱️ Timeout Warning\n\n${error.message}\n\n💡 ${error.suggestion}`;
            } else if (response.status === 504) {
              errorMessage = `⏱️ Gateway Timeout (504)\n\nThe AI rendering took too long (>10s free tier limit).\n\n💡 Solutions:\n• Upgrade to Vercel Pro (60s timeout)\n• Run locally for development\n• See DEPLOYMENT.md for details`;
            }
            
            if (error.stack && process.env.NODE_ENV === 'development') {
              console.error('Server error stack:', error.stack);
            }
            if (errorDetails) {
              console.error('Full error details:', errorDetails);
            }
          } catch (e) {
            // If response is not JSON, use status text
            if (response.status === 504) {
              errorMessage = `⏱️ Gateway Timeout (504)\n\nThe server didn't respond in time. This happens on Vercel Free tier.\n\n💡 Upgrade to Pro or run locally.`;
            } else {
              errorMessage = response.statusText || errorMessage;
            }
          }
          throw new Error(errorMessage);
        }

        const data = await response.json();
        
        // Update concept ID for this project
        if (data.conceptId) {
          currentConceptId = data.conceptId;
          currentProjectId = projectId;
          updateConceptStatusIndicator(); // Update the status indicator
        }
        
        showResult(data);
        showStatus('Rendering generated successfully!', 'success');
      } catch (error) {
        console.error('Error:', error);
        showStatus(`Error: ${error.message}`, 'error');
      } finally {
        submitBtn.disabled = false;
      }
    }

    // Helper function: Job-based render with polling
    async function handleJobBasedRender(projectId, conceptBrief, outputType) {
      showStatus('Generating concept', 'info');

      try {
        const renderTypeMap = {
          'concept_axonometric': 'axonometric',
          'concept_plan': 'floor_plan',
          'concept_section': 'section',
        };
        const renderType = renderTypeMap[outputType] || 'axonometric';

        const payload = {
          projectId: projectId,
          renderType: renderType,
          conceptInputs: conceptBrief,
        };

        // Only add concept ID for plan/section views (to correlate with existing axon)
        // For axonometric renders, do NOT pass conceptId to allow new concept generation
        if (renderType === 'floor_plan' || renderType === 'section') {
          if (currentConceptId && currentProjectId === projectId) {
            payload.conceptId = currentConceptId;
          }
        }

        // Add selectedBuildingId if user selected a candidate
        if (selectedBuildingId) {
          payload.selectedBuildingId = selectedBuildingId;
        }

        // Add manual overrides if provided
        const overrideBuildingForm = document.getElementById('overrideBuildingForm').value;
        const overrideStoreys = document.getElementById('overrideStoreys').value;
        const overrideRoofAssumption = document.getElementById('overrideRoofAssumption').value;
        const overrideFootprintScale = document.getElementById('footprintScaleOverride') ? document.getElementById('footprintScaleOverride').value : '';
        
        if (overrideBuildingForm || overrideStoreys || overrideRoofAssumption || overrideFootprintScale) {
          payload.baselineOverrides = {};
          if (overrideBuildingForm) {
            payload.baselineOverrides.buildingForm = overrideBuildingForm;
          }
          if (overrideStoreys) {
            payload.baselineOverrides.storeys = overrideStoreys;
          }
          if (overrideRoofAssumption) {
            payload.baselineOverrides.roofAssumption = overrideRoofAssumption;
          }
          if (overrideFootprintScale) {
            payload.baselineOverrides.footprintScale = overrideFootprintScale;
          }
        }

        // Add address/latlng for site lookup if available
        if (geocodeResult) {
          payload.address = addressInput.value.trim();
          payload.lat = geocodeResult.lat;
          payload.lng = geocodeResult.lng;
        }

        // Step 1: Create job (fast, <1s)
        const createResponse = await fetch(`${API_URL}/api/jobs/render`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
        });

        if (!createResponse.ok) {
          const error = await createResponse.json();
          throw new Error(error.message || 'Failed to create job');
        }

        const jobData = await createResponse.json();
        const { jobId, conceptId: finalConceptId } = jobData;

        showStatus('Generating concept', 'info');

        // Step 2: Trigger job processing (in background)
        // Note: This will still timeout on free tier, but we return immediately
        fetch(`${API_URL}/api/jobs/${jobId}/process`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            projectId: projectId,
            conceptInputs: conceptBrief,
          }),
        }).catch(err => {
          console.warn('Background processing may have timed out:', err);
          // This is expected on free tier - polling will handle it
        });

        // Step 3: Poll for completion
        let pollAttempts = 0;
        const maxPollAttempts = 120; // 2 minutes (1s intervals)
        const pollInterval = 1000; // 1 second

        const pollForCompletion = async () => {
          try {
            const statusResponse = await fetch(`${API_URL}/api/jobs/${jobId}?projectId=${projectId}`);
            
            if (!statusResponse.ok) {
              throw new Error('Failed to check job status');
            }

            const { job } = await statusResponse.json();

            // Update status message
            const progressText = job.progress ? ` (${job.progress}%)` : '';
            showStatus('Generating concept', 'info');

            if (job.status === 'completed') {
              // Job completed successfully
              if (finalConceptId) {
                currentConceptId = finalConceptId;
                currentProjectId = projectId;
                updateConceptStatusIndicator();
              }

              showResult({
                conceptId: finalConceptId,
                renderType: renderType,
                imageUrl: job.imageUrl,
                promptVersion: job.promptVersion,
                conceptRange: job.conceptRange,
              });
              showStatus('Rendering completed successfully!', 'success');
              submitBtn.disabled = false;
              return;
            }

            if (job.status === 'failed') {
              throw new Error(job.error || 'Job failed');
            }

            // Continue polling if pending or processing
            pollAttempts++;
            if (pollAttempts >= maxPollAttempts) {
              throw new Error('Job timed out waiting for completion');
            }

            setTimeout(pollForCompletion, pollInterval);
          } catch (error) {
            console.error('Polling error:', error);
            showStatus(`Error: ${error.message}`, 'error');
            submitBtn.disabled = false;
          }
        };

        // Start polling after a short delay
        setTimeout(pollForCompletion, 2000);

      } catch (error) {
        console.error('Error:', error);
        showStatus(`Error: ${error.message}`, 'error');
        submitBtn.disabled = false;
      }
    }
  </script>
  </script>
</body>
</html>


